(unless (assoc "~/code/gobble" (library-directories))
  (library-directories (cons "~/code/gobble" (library-directories))))

(import (gobble)
        (trie)
        (dictionary)
        (chezscheme)
        (euler)
        (only (srfi :1) append-map))

(random-seed (time-nanosecond (current-time)))
(random-seed (random (time-nanosecond (current-time))))

(define N
  (if (null? (cdr (command-line)))
      1
      (with-input-from-string (cadr (command-line)) read)))

(define words
  (make-hashtable string-hash string=?))

(define (freq)
  (do ((i 0 (1+ i)))
      ((= i N)
       (vector-for-each (lambda (w.n)
                          (display (car w.n))
                          (display #\space)
                          (display (cdr w.n))
                          (newline))
                        (vector-sort (lambda (x y)
                                       (>= (cdr x) (cdr y)))
                                     (hashtable-cells words))))
    
    (for-all (lambda (word)
               (hashtable-update! words word fx1+ 0))
             (gobble (list->string (roll))))))

(define (remove-one xs x)
  (define (aux xs)
    (cond ((null? xs) '())
          ((eq? (car xs) x) (cdr xs))
          (else (cons (car xs) (aux (cdr xs))))))
  (aux xs))

(define (anagrams word)
  (define anas (make-hashtable string-hash string=?))
  (define (aux T path letters)
    (when (trie-element T)
      (hashtable-set! anas (string-downcase (list->string (reverse path))) #t))
    (for-all (lambda (y)
               (let ((y.T (lookup-char T y)))
                 (when (pair? y.T)
                   (aux (cdr y.T) (cons y path) (remove-one letters y)))))
             (nub-eq letters)))
  (aux collins '() (string->list (string-upcase word)))
  (sort-on string-length (vector->list (hashtable-keys anas))))

(define (possible-combos letters)
  (filter-map (lambda (ijk)
                (let ((word (list->string (map integer->char ijk))))
                  (and (definition word) word)))
              (nub-equal (permutations letters))))

(define (word-combos word)
  (possible-combos (map char->integer (string->list word))))

(define (eq-len-combos word)
  (define n (string-length word))
  (filter (compose (curry = n) string-length) (anagrams word)))

(define (3x3s)
  (define combos (make-hash-table))
  (define (show-defs words)
    (format #t "--- ~a ---~%" words))
  (define (report)
    (for-all show-defs (hashtable-ref combos 3 '()))
    (for-all show-defs (hashtable-ref combos 4 '()))
    (for-all show-defs (hashtable-ref combos 5 '())))
  (do ((i 97 (1+ i)))
      ((> i 122)
       ;;        (report)
       combos)
    (do ((j i (1+ j)))
        ((> j 122))
      (do ((k j (1+ k)))
          ((> k 122))
        (let* ((ijk (list i j k))
               (words (possible-combos ijk))
               (n (length words)))
          (when (< 0 n)
            (hashtable-update! combos
                               (length words)
                               (lambda (cs)
                                 (cons words cs))
                               '())))))))
